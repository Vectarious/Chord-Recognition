# Chord-Recognition

## 1. Initialization:
For my  project, I implemented a chord recognition algorithm. I used `mirchromagram` from the [MIR Toolbox](https://www.mathworks.com/matlabcentral/fileexchange/24583-mirtoolbox) to generate my initial chromagram, and then manipulated that data to create a fairly accurate chord recognition program. The first section of the code is just establishing the mirchromagram object and deciphering its output into something useful. This was done using the `get` function with the `"Magnitude”` parameter to get the strength of each chroma over time. Additionally, this section was where I generated my templates which would later be tested on each column of the chromagram. This was done using the helper function `generate_templates`.

## 2. Main Loop:
The main loop begins by establishing a `threshold` for the chromagram indexing. I was
running a bit short on time, so I wasn’t able to determine an algorithm for the optimal threshold cutoff, but I included suggestions for the files in my directory. The default threshold is set to 0.2 if you try using your own files. The main loop of the code goes through each column of the chromagram and cleans it by polarizing the magnitudes to 0 or 1. To be polarized to 1, the indexed chroma needs to be above the threshold, and also have a top-4 magnitude. This is to avoid allowing chords with more than 4 notes, since none of the templates account for this (yet)! Essentially, the magnitudes are sorted so a maximum of the top 4 pitches are allowed through.
 The next step is to find the best guess for the chord quality of each column of the chromagram. For each column, the polarized data was reviewed with each template corresponding to a similar number of pitches. This means that the minor 7th template would never be used on a 3-pitch column, which saves a bit of time in the long run. The `cycle_template_match()` helper function was used to test the templates, and the number of times it was cycled determined the root—0 rotations corresponded with C, 1 with Db, 2 with E, and so on. If a match was found, the root would be calculated this way, and the quality would be indexed as well using the initial generated `chord_quality` array. These variables are stored in the `chord_storage` array for data manipulation.

## 3. Data Manipulation:
The first step is to clean this data, since chords tend to bounce around a lot between individual samples. This was done using a `mode` of 10 neighbors on either side. Now that the data was relatively clean, the chords were condensed with time, meaning a new `chord_time_info` array tracked the beginning and end time of each chord, as well as its root and quality found from before. This was done by checking if there had been a change from the chord before, as the `new_chord` boolean variable could be toggled to trigger a condition which would add a new row to the array. Once the array had been completed with information on all chords, a second cleaning process needed to occur. The `mode` function left some off-by-one issues where the chord root was left for an instance too long after the quality had changed, so this cleaning removed this issue by making sure no chord could last for less than 3 time samples. The `chord_time_info` array was then separated in order to create a `string_chord_info` array to keep the actual strings of the note name and quality, rather than placeholder numbers. This was all the information needed from this phase of the code.

## 4. Data Visualization:
In order to visualize the data, a plot of the original audio file was created to view the progression of time. Using the built-in `audioplayer` function, a `TimerPeriod` was set up to update every .05 seconds. A `playerhead` was created as a vertical time which would move by .05 on the x-axis to represent the passage of time (since the x-axis is measured in seconds). Additionally, a text object `chord_name` was initialized which would be displayed next to the `playerhead` throughout the process. All of the details for how this was done can be found in the “Helper Functions” section of the code under `handleEvent`, but while it did take me several hours to get it working, it isn’t actually all that hard to understand.

## 5. Helper Functions:
Only 1 other helper function was not mentioned already. The `pitch_counter` function
simply counts all the 1s in a column, therefore determining how many pitches are in a column of the cleaned chromagram. All of the other functions have been described, and they are also documented at the bottom of the code itself. I will mention that the `generate_templates` function is very easy to add additional chord types to, so implementing 9th chords in the future would not be particularly difficult!
Conclusions:
Overall, I would say this was a successful project given my short time window of work (about 30 hours). The program appears reasonably successful with random chordal files such as the jazz guitar clips I downloaded from YouTube, and it works very well for my curated chord files made in Logic. While there are certainly blips where it doesn’t know how to evaluate a given instance of time, this is normally due to a powerful lead instrument which weakens the harmonic chroma, so this is an expected result. There are definitely ways to improve the algorithm, including the creation of an automatic threshold generator—my current manual approach is not great, but I believe it shows good potential that the model can work. I hope you enjoy playing around with it!
